# corrected_wekinator_mediapipe.py
import cv2
import mediapipe as mp
from pythonosc.udp_client import SimpleUDPClient
from pythonosc.dispatcher import Dispatcher
from pythonosc.osc_server import ThreadingOSCUDPServer
import threading
import time
import serial
import serial.tools.list_ports

# ===================== CONFIG =====================

# --- Wekinator input  ---
WEKINATOR_HOST = "127.0.0.1"
WEKINATOR_INPUT_PORT = 6448
WEKINATOR_INPUT_ADDRESS = "/wek/inputs"

# --- Wekinator output (this script listens here) ---
WEKINATOR_OUTPUT_IP = "0.0.0.0"
WEKINATOR_OUTPUT_PORT = 12000
WEKINATOR_OUTPUT_ADDRESS = "/wek/outputs"

# --- Arduino serial (optional) ---
ARDUINO_PORT = "/dev/cu.usbmodem1101"   # set to your port or leave as-is if not using Arduino
ARDUINO_BAUD = 9600                    # <- use an integer baud rate. Typical is 9600.
SERIAL_WRITE_LINE_ENDING = "\n"
SERIAL_READ_TIMEOUT_SEC = 0.1

# --- MediaPipe / camera ---
CAMERA_INDEX = 0
FRAME_WIDTH = 640
FRAME_HEIGHT = 360
MAX_NUM_HANDS = 2
SEND_ZERO_VECTOR_WHEN_NO_HAND = True
TARGET_FPS = 30

# --- Features ---
USE_XYZ = True

# --- Coordinate space: "world" or "image" ---
COORDINATE_SPACE = "world"

# --- Mapping from Wekinator two-value output to Arduino command numbers 1..9 ---
WEKINATOR_TO_ARDUINO_MAP = {
    ("1", "1"): 5,  # stop all (onehand - palm)
    ("1", "2"): 8,  # draw circle (two hands- make circle)
    ("1", "3"): 7,  # draw triangle (two hands - make triangle)
    ("1", "4"): 6,  # draw square (two hands - make rectangle)
    ("5", "5"): 9,  # default (no hands shown)
    ("4", "5"): 1,  # point left (one hand)
    ("3", "5"): 2,  # point right (one hand)
    ("2", "5"): 3,  # point down (one hand)
    ("1", "5"): 4,  # point up (one hand)
}

DEFAULT_ARDUINO_ON_UNKNOWN = 5

# ===============================================================

wek_client = SimpleUDPClient(WEKINATOR_HOST, WEKINATOR_INPUT_PORT)

ser = None
def try_open_serial():
    global ser
    try:
        baud = int(ARDUINO_BAUD) if not isinstance(ARDUINO_BAUD, int) else ARDUINO_BAUD
        ser = serial.Serial(ARDUINO_PORT, baud, timeout=SERIAL_READ_TIMEOUT_SEC)
        print(f"[INFO] Opened serial: {ARDUINO_PORT} @ {baud}")
    except Exception as e:
        print(f"[WARN] Could not open serial on {ARDUINO_PORT}: {e}")
        ser = None

try_open_serial()

def serial_reader():
    global ser
    while True:
        if ser is None:
            time.sleep(0.5)
            continue
        try:
            line = ser.readline()
            if line:
                try:
                    text = line.decode(errors="replace").rstrip("\r\n")
                except Exception:
                    text = str(line)
                print(f"FROM ARDUINO: {text}")
        except Exception as e:
            print(f"[WARN] Serial read error: {e}")
            try:
                if ser:
                    ser.close()
            except:
                pass
            ser = None
            time.sleep(1.0)
            try_open_serial()

serial_thread = threading.Thread(target=serial_reader, daemon=True)
serial_thread.start()

# ======== OSC receive & mapping logic ========

def _normalize_to_pair(args):
    """
    Accept raw args (tuple) from OSC and return (a_label, b_label) as strings.
    Returns (None, None) on failure.
    """
    if not args:
        return (None, None)

    # If there are at least two args, convert first two to integer-like strings
    if len(args) >= 2:
        def to_label(v):
            try:
                if isinstance(v, (int, float)):
                    return str(int(round(v)))
                s = str(v).strip()
                # try to parse as float, then int
                try:
                    f = float(s)
                    return str(int(round(f)))
                except:
                    return s
            except:
                return None
        a = to_label(args[0])
        b = to_label(args[1])
        return (a, b)

    # Single argument: try to parse "1-2", "1,2", "1 2" etc.
    single = args[0]
    s = str(single).strip()
    for sep in ("-", ",", " ", "/"):
        if sep in s:
            parts = [p.strip() for p in s.split(sep) if p.strip() != ""]
            if len(parts) >= 2:
                def norm_part(p):
                    try:
                        f = float(p)
                        return str(int(round(f)))
                    except:
                        return p
                return (norm_part(parts[0]), norm_part(parts[1]))
    return (None, None)

def on_wekinator_output(address, *args):
    """
    Handler for incoming OSC from Wekinator. Maps the two-value output to an Arduino command
    and writes a single integer + newline to the serial port (if available).
    """
    values = list(args)
    try:
        LAST_WEK_MSG = ", ".join(f"{v:.4f}" if isinstance(v, (int, float)) else str(v) for v in values)
    except Exception:
        LAST_WEK_MSG = str(values)
    print(f"[WEKINATOR OUTPUT] {address} -> {LAST_WEK_MSG}")

    a_label, b_label = _normalize_to_pair(values)
    print(f"[DEBUG] Parsed pair -> ({a_label}, {b_label})")

    arduino_cmd = None
    if a_label is not None and b_label is not None:
        key = (a_label, b_label)
        if key in WEKINATOR_TO_ARDUINO_MAP:
            arduino_cmd = WEKINATOR_TO_ARDUINO_MAP[key]
        else:
            swapped = (b_label, a_label)
            if swapped in WEKINATOR_TO_ARDUINO_MAP:
                arduino_cmd = WEKINATOR_TO_ARDUINO_MAP[swapped]

    if arduino_cmd is None:
        if DEFAULT_ARDUINO_ON_UNKNOWN is not None:
            arduino_cmd = DEFAULT_ARDUINO_ON_UNKNOWN
            print(f"[INFO] Unrecognized pair ({a_label}, {b_label}). Sending default Arduino command: {arduino_cmd}")
        else:
            print(f"[WARN] Unrecognized Wekinator pair: ({a_label}, {b_label}) — not sending to Arduino.")
            return

    # Send to Arduino
    if ser is not None:
        try:
            line = f"{arduino_cmd}{SERIAL_WRITE_LINE_ENDING}"
            ser.write(line.encode())
            print(f"[SENT TO ARDUINO] {line.strip()}")
        except Exception as e:
            print(f"[WARN] Serial write failed: {e}")
    else:
        print(f"[INFO] (Serial closed) Would send to Arduino: {arduino_cmd}")
        # try re-open once
        try_open_serial()
        if ser is not None:
            try:
                line = f"{arduino_cmd}{SERIAL_WRITE_LINE_ENDING}"
                ser.write(line.encode())
                print(f"[SENT TO ARDUINO after reopen] {line.strip()}")
            except Exception as e:
                print(f"[WARN] Serial write failed after reopen: {e}")

dispatcher = Dispatcher()
dispatcher.map(WEKINATOR_OUTPUT_ADDRESS, on_wekinator_output)
dispatcher.set_default_handler(lambda addr, *a: on_wekinator_output(addr, *a))

osc_server = ThreadingOSCUDPServer((WEKINATOR_OUTPUT_IP, WEKINATOR_OUTPUT_PORT), dispatcher)
server_thread = threading.Thread(target=osc_server.serve_forever, daemon=True)
server_thread.start()
print(f"[INFO] OSC server listening for Wekinator outputs on {WEKINATOR_OUTPUT_IP}:{WEKINATOR_OUTPUT_PORT}")

# ====== MediaPipe Hands (unchanged) ======
mp_hands = mp.solutions.hands
mp_draw = mp.solutions.drawing_utils
mp_style = mp.solutions.drawing_styles

hands = mp_hands.Hands(
    static_image_mode=False,
    max_num_hands=MAX_NUM_HANDS,
    min_detection_confidence=0.5,
    min_tracking_confidence=0.5
)

cap = cv2.VideoCapture(CAMERA_INDEX)
if not cap.isOpened():
    raise RuntimeError("Could not open webcam. Try a different CAMERA_INDEX.")

cap.set(cv2.CAP_PROP_FRAME_WIDTH, FRAME_WIDTH)
cap.set(cv2.CAP_PROP_FRAME_HEIGHT, FRAME_HEIGHT)

last_sent = 0.0
send_interval = 1.0 / max(1, TARGET_FPS)

def _extract_vector_from_landmarks(hand_lms, use_xyz=True):
    vec = []
    if hand_lms is None:
        return vec
    if use_xyz:
        for lm in hand_lms:
            vec.extend([lm.x, lm.y, lm.z])
    else:
        for lm in hand_lms:
            vec.extend([lm.x, lm.y])
    return vec

def _pad_to_per_hand(vec, use_xyz=True):
    per = 63 if use_xyz else 42
    if vec is None:
        return [0.0] * per
    vec = list(vec)
    if len(vec) < per:
        vec += [0.0] * (per - len(vec))
    elif len(vec) > per:
        vec = vec[:per]
    return vec

print(f"[INFO] Sending features to Wekinator at {WEKINATOR_HOST}:{WEKINATOR_INPUT_PORT} {WEKINATOR_INPUT_ADDRESS}")
print(f"[INFO] Coordinate space: {COORDINATE_SPACE} (USE_XYZ={USE_XYZ})")
print("Press ESC or q to quit.")

try:
    while True:
        ok, frame = cap.read()
        if not ok:
            break

        frame = cv2.flip(frame, 1)
        rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
        res = hands.process(rgb)

        if getattr(res, "multi_hand_landmarks", None):
            for lm in res.multi_hand_landmarks:
                mp_draw.draw_landmarks(
                    frame, lm, mp_hands.HAND_CONNECTIONS,
                    mp_style.get_default_hand_landmarks_style(),
                    mp_style.get_default_hand_connections_style()
                )

        detected = []
        left_landmarks = None
        right_landmarks = None

        multi_world = getattr(res, "multi_hand_world_landmarks", None)
        multi_image = getattr(res, "multi_hand_landmarks", None)
        handedness = getattr(res, "multi_handedness", None)

        if COORDINATE_SPACE.lower() == "world" and multi_world:
            for i, w in enumerate(multi_world):
                label = None
                if handedness and i < len(handedness):
                    try:
                        label = handedness[i].classification[0].label
                    except:
                        label = None
                detected.append({"landmarks": w.landmark, "label": label})
        else:
            for i, im in enumerate(multi_image or []):
                label = None
                if handedness and i < len(handedness):
                    try:
                        label = handedness[i].classification[0].label
                    except:
                        label = None
                detected.append({"landmarks": im.landmark, "label": label})

        if len(detected) >= 2:
            for d in detected[:2]:
                if d["label"] == "Left":
                    left_landmarks = d["landmarks"]
                elif d["label"] == "Right":
                    right_landmarks = d["landmarks"]
            remaining = [d for d in detected[:2] if d["landmarks"] not in (left_landmarks, right_landmarks)]
            if left_landmarks is None and remaining:
                left_landmarks = remaining.pop(0)["landmarks"]
            if right_landmarks is None and remaining:
                right_landmarks = remaining.pop(0)["landmarks"]
        elif len(detected) == 1:
            d = detected[0]
            if d["label"] == "Left":
                left_landmarks = d["landmarks"]
            elif d["label"] == "Right":
                right_landmarks = d["landmarks"]
            else:
                xs = [lm.x for lm in d["landmarks"]]
                centroid_x = (sum(xs) / len(xs)) if xs else 0.5
                if centroid_x < 0.5:
                    left_landmarks = d["landmarks"]
                else:
                    right_landmarks = d["landmarks"]

        left_vec = _extract_vector_from_landmarks(left_landmarks, USE_XYZ) if left_landmarks else []
        right_vec = _extract_vector_from_landmarks(right_landmarks, USE_XYZ) if right_landmarks else []

        left_vec = _pad_to_per_hand(left_vec, USE_XYZ)
        right_vec = _pad_to_per_hand(right_vec, USE_XYZ)

        out_vec = left_vec + right_vec

        now = time.time()
        if out_vec is not None and (now - last_sent) >= send_interval:
            wek_client.send_message(WEKINATOR_INPUT_ADDRESS, out_vec)
            LAST_SENT_COUNT = len(out_vec)
            print(f"TO WEKINATOR: {LAST_SENT_COUNT} floats, sample:", [round(v, 4) for v in out_vec[:12]], "...")
            last_sent = now

        cv2.putText(frame, f"To Wekinator: {WEKINATOR_INPUT_ADDRESS} {LAST_SENT_COUNT} floats (Left then Right)",
                    (10, 22), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (50,50,50), 1, cv2.LINE_AA)
        cv2.putText(frame, f"From Wekinator: OSC {WEKINATOR_OUTPUT_PORT}", (10, 46), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (50,50,50), 1, cv2.LINE_AA)
        cv2.putText(frame, f"Coord space: {COORDINATE_SPACE}", (10, 70), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (50,50,50), 1, cv2.LINE_AA)
        cv2.putText(frame, "Press ESC or q to quit.", (10, frame.shape[0] - 10),
                    cv2.FONT_HERSHEY_SIMPLEX, 0.5, (50,50,50), 1, cv2.LINE_AA)

        cv2.imshow("MediaPipe ↔ Wekinator (two hands)", frame)

        key = cv2.waitKey(1) & 0xFF
        if key in [27, ord('q')]:
            break

finally:
    cap.release()
    cv2.destroyAllWindows()
    hands.close()
    try:
        osc_server.shutdown()
    except:
        pass
    try:
        if ser:
            ser.close()
    except:
        pass
